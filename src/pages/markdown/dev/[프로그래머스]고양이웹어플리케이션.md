---
title: "[프로그래머스 과제] 고양이 사진첩 만들기"
date: "2021-05-20"
folder: "dev"
tags: ["코딩테스트", "과제테스트", "Vanila JavaScript", "자바스크립트", "프로그래머스"]
---

> *출처: 프로그래머스 과제란 고양이 사진첩 만들기*
> 
> *https://programmers.co.kr/skill_check_assignments/100*



```bash
|-- index.html
|-- script.js
|-- assets
     |-- directory.png
     |-- file.png
     |-- nyan-cat.gif
     |-- prev.png
|-- src
     |-- App.js
     |-- utils
          |--index.js
     |-- styles
          |--styles.css
     |components
          |--node
              |--directory.js
              |--prev.js
              |--file.js
          |--Elem.js
          |--Nodes.js
          |--Nav.js
``` 


# 컴포넌트

## `Elem`
 1. 가장 작은단위의 컴포넌트로 생성자에 들어오는 `부모 컴포넌트`, `HtmlElementType`, `ClassName`이 결정된다.
 
 2. `HtmlElement` 을 빠르고, 한줄로 만들기 위해서 작성함.

```js
export default class Elem {
  ref;
  constructor({ parent, refName, className }) {
    this.ref = document.createElement(refName);
    this.ref.className = className;
    parent.appendChild(this.ref);
  }
}
```

## `Directory`
 1. Nodes 의 Node 종류중 하나이며, `폴더` 형식을 의미한다.
 2. Directory를 클릭하면 Data를 불러와서 해당하는 `Data(Nodes)` 들에 대하여 상태를 변화 시켜주고 그에 맞게 Render를한다.
```js
import App from "../../App.js";
import { getData } from "../../utils/index.js";
import Elem from "../Elem.js";

export default class Directory {
  ref;
  childImage;
  id;
  childDiv;
  name;
  constructor(parent, name, id) {
    const node = new Elem({ parent, refName: "div", className: "Node", id });
    const image = new Elem({
      parent: node.ref,
      refName: "img",
      className: "",
      id,
    });
    image.ref.setAttribute("src", "./assets/directory.png");
    const div = new Elem({
      parent: node.ref,
      refName: "div",
      className: "",
      id,
    });
    div.ref.innerHTML = name;

    this.id = id;
    this.name = name;
    this.childImage = image.ref;
    this.childDiv = div.ref;
    this.childDiv.addEventListener("click", this.onClick);
    this.childImage.addEventListener("click", this.onClick);
  }

  onClick = async () => {
    if (App.state.isLoading) return;
    const datas = await getData(this.id);
    App.setState({
      navStack: [...App.state.navStack, { id: this.id, name: this.name }],
    });
    App.state.Breadcrumb.setState({ navStack: App.state.navStack });
    App.state.Nodes.setState({ Node: datas });
  };
}
```

## `File`
 1. Nodes 의 Node 종류중 하나이며, `파일(이미지)` 형식을 의미한다.
 2. File을 클릭하면 Data를 불러와서 해당하는 Data 에 대하여 `Image Modal` 창을 `Toggle`한다
```js
import App from "../../App.js";
import Elem from "../Elem.js";

const _URL_ =
  "https://fe-dev-matching-2021-03-serverlessdeploymentbuck-t3kpj3way537.s3.ap-northeast-2.amazonaws.com/public";
export default class File {
  ref;
  childImage;
  childDiv;
  filePath;
  constructor(parent, name, id, filePath) {
    const node = new Elem({ parent, refName: "div", className: "Node", id });
    const image = new Elem({
      parent: node.ref,
      refName: "img",
      className: "",
      id,
    });
    image.ref.setAttribute("src", "./assets/file.png");
    const div = new Elem({
      parent: node.ref,
      refName: "div",
      className: "",
      id,
    });
    div.ref.innerHTML = name;

    this.filePath = filePath;
    this.childImage = image.ref;
    this.childDiv = div.ref;
    this.childDiv.addEventListener("click", this.onClick);
    this.childImage.addEventListener("click", this.onClick);
  }

  onClick = async () => {
    if (App.state.isLoading) return;
    App.toggle("Image");
    App.state.ImageViewrContent.src = _URL_ + this.filePath;

    App.state.ImageViewrContent.onerror = () => {
      window.alert("error!");
      App.toggle("Image");
    };

    App.state.ImageViewr.addEventListener("click", (e) => {
      if (e.currentTarget === e.target) {
        App.state.isImageFull && App.toggle("Image");
      }
    });

    document.body.addEventListener("keydown", (e) => {
      if (e.code === "Escape") {
        App.state.isImageFull && App.toggle("Image");
      }
    });
  };
}
```

## `Prev`
 1. Nodes 의 Node 종류중 하나이며, `Prev(뒤로가기)` 형식을 의미한다.
 2. Prev를 클릭하면 NavStack이 하나 빠지고난 뒤 맨 뒤에 있는 위치에 해당하는 Data를 불러와서 Nodes를 render를 해준다
```js
import App from "../../App.js";
import { getData } from "../../utils/index.js";
import Elem from "../Elem.js";

export default class Prev {
  ref;
  childImage;
  constructor(parent, id) {
    const node = new Elem({ parent, refName: "div", className: "Node", id });
    this.ref = node.ref;
    const image = new Elem({
      parent: this.ref,
      refName: "img",
      className: "",
      id,
    });
    image.ref.setAttribute("src", "./assets/prev.png");
    this.childImage = image.ref;

    this.id = id;
    this.childImage = image.ref;
    this.childImage.addEventListener("click", this.onClick);
  }

  onClick = async () => {
    if (App.state.isLoading) return;
    const datas = await getData(this.id);
    App.setState({
      navStack: [...App.state.navStack]
        .map((stack, i) =>
          i !== App.state.navStack.length - 1 ? stack : false
        )
        .filter((v) => !!v),
    });
    App.state.Breadcrumb.setState({ navStack: App.state.navStack });
    App.state.Nodes.setState({ Node: datas });
  };
}
```
  

## `Nodes: document.querySelector(".Nodes")`
 1. Node들을 관리하는 상위 컴포넌트`(Container 역할을 한다)`
 2. `render()`가 호출이 되면, `state`에 있는 `Node`에 있는 `Data`에 맞춰서 그에 맞는 `Node 컴포넌트를 생성한다`
 ```
`Nodes` 안에 있는 Node State는 {id, name, type, filePath, parent} 등을 갖고 있다.

filePath가 있으면, `File` 이고, 없으면 `Directory` 이기 때문에, 그에 맞춰 컴포넌트를 생성한다.

NavStack 에 맞춰서 `Root Directory` 일 때를 제외하고 `Prev` 컴포넌트 를 만든다.
```

```js
// Nodes.js
  render() {
    // render 될 때마다 this.Nodes = (document.querySelector('.Nodes")) 초기화
    this.Nodes.innerHTML = "";
    if (App.state.navStack.length > 1) {
      new Prev(
        this.Nodes,
        App.state.navStack[App.state.navStack.length - 2].id
      );
    }
    this.state.Node?.map((obj) => {
      const { name, id, filePath } = obj;
      if (filePath !== null) {
        new File(this.Nodes, name, id, filePath);
      } else {
        new Directory(this.Nodes, name, id);
      }
    });
  }
```

## `Nav: document.querySelector(".Breadcrumb")`
   1. Breadcrumb 컴포넌트를 관리하는 파일
   2. NavStack 이 변화할때마다. (App.setState() 를 통해 변화 할때마다) BreadCrumb를 그려준다.


## `App: document.querySelector(".main")`
  1. Main 컴포넌트를 관리하는 파일
  2. setState를 하게 되면 하위컴포넌트(`Nodes`, `Navs`)를 `render()` 한다.
  3. 맨 처음 페이지가 로드 되면, `init()`을 실행하는데, data를 받아와서 Nodes에 저장한다.
  4. 다른 곳에서 상태 관리를 하기 위해서 모든 변수및 함수들을 정적으로 정의 하였다.


```js
import Nav from "./components/Nav.js";
import Nodes from "./components/Nodes.js";
import { getData } from "./utils/index.js";

const initialState = {
  navStack: [{ name: "root", id: "" }],
  Breadcrumb: new Nav(),
  Nodes: new Nodes(),
  Loading: document.querySelector(".Loading"),
  ImageViewr: document.querySelector(".ImageViewer"),
  ImageViewrContent: document.querySelector(".image-content"),
  isLoading: false,
  isImageFull: false,
  cache: {},
};

export default class App {
  static main = document.querySelector(".App");
  static state = initialState;
  constructor() {}

  static setState = (nextState) => {
    this.state = {
      ...this.state,
      ...nextState,
    };
    this.render();
  };

  static render() {
    App.state.Breadcrumb.render();
    App.state.Nodes.render();
  }

  static async init() {
    const datas = await getData("");
    App.state.Nodes.setState({ Node: datas });
    App.state.Breadcrumb.setState({ navStack: App.state.navStack });
    this.render();
  }

  static toggle(type) {
    if (type === "Loading") {
      if (App.state.isLoading) {
        App.state.Loading.className = "hide Modal Loading";
        App.setState({ isLoading: false });
      } else {
        App.state.Loading.className = "Modal Loading";
        App.setState({ isLoading: true });
      }
    } else {
      if (App.state.isImageFull === true) {
        App.state.ImageViewr.className = "hide Modal ImageViewr";
        App.setState({ isImageFull: false });
      } else {
        App.state.ImageViewr.className = "Modal ImageViewr";
        App.setState({ isImageFull: true });
      }
    }
  }
}
```


# 아쉬운 점
1. NavStack 과 같은 배열을 사용하지않고 불러온 Data의 Parent Id를 이용하는 것이 좋았을 것 같다.

2. App에서만 상태관리를 하였는데, 그와 다르게 React 구조처럼 컴포넌트 각각에서 상태 관리를 하여서 상태가 변환 컴포넌트만 랜더링되게만 하였으면 어떨까 싶다.

3. Node의 Div, Img 구조가 반복되는 데 이를 또 따로 컴포넌트로서 구성했어야 했다.

4. `Class` 형식이 아닌 `Functional` 형식으로 짜는 방법이 조금더 유연했을 것 같다.